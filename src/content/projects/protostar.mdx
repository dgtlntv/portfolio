---
title: Proto*
date: "11.07.2024"
slug: protostar
excerpt:
    While doing user research for one of Canonicals CLIs I realised there are no
    good tools for prototyping and user testing CLIs. So I created my own –
    Protostar.
coverImage: "/videos/projects/protostar/protostar.webm"
heroLocation: "cover"
asciiDarken: 3.0
stats:
    [{ label: "Year", value: "2024" }, { label: "Type", value: "Work Project" }]
---

The digital infrastructure software that Canonical develops can be quite
challenging to set up and install. And so was MAAS (Metal as a Service) the
product I was working on at the time. Especially if you want to deploy MAAS in
high-availability (HA) (setting up 3 identical installations so if one fails
another one can take over) things can become tricky. Thats why the MAAS team
worked on a CLI tool that makes installing MAAS in HA easier. We were preparing
MAAS Anvil for a Beta release so we wanted to identify any significant usability
gaps beforehand. We also wanted to understand better how best to add new
features we were considering adding which had several implementation options,
but we weren't certain which experience would work best for our users.

<FanImages
    images={[
        {
            src: "/images/projects/maas-anvil/research-prep-3.png",
            alt: "Research preparation document 1",
        },
        {
            src: "/images/projects/maas-anvil/research-prep-2.png",
            alt: "Research preparation document 2",
        },
        {
            src: "/images/projects/maas-anvil/research-prep-1.png",
            alt: "Research preparation document 3",
        },
    ]}
    caption="Research preparation documents outlining study objectives and methodology"
/>

I began by creating a comprehensive research brief outlining the purpose of the
study, the assumptions we wanted to test, and our methodology. After sharing
this with the team to ensure alignment on research objectives, I developed an
interview guide that would help us understand user behaviors and preferences.
During this process, I realized that testing different feature implementation
options would require some form of prototype.

## User testing CLIs

But the problem is that there aren't any good options for prototyping and user
testing command-line interfaces. Figma prototypes were inadequate because users
couldn't type actual commands, only click through predetermined paths. Simply
reviewing command structures in a document failed to provide the interaction
depth of a real CLI experience. And while coding a functioning CLI would be
technically possible, it would require participants to install software before
interviews. An immediate barrier when working with system administrators who are
understandably skeptical about installing unknown packages on their systems.
Ideally, the solution would be as frictionless as Figma prototypes, where
researchers can simply send a link to participants.

This prompted me to hack together a CLI prototypiong tool on my own on a friday
afternoon. I knew about [xterm.js](https://xtermjs.org/), a terminal library
used by established apps like Visual Studio Code. Is used it and other libraries
to build a prototype that emulated a terminal environment entirely in the
browser, with no installation required.

<FloatImage
    direction="left"
    src="/images/projects/maas-anvil/maas-anvil-user-testing.png"
>
    Despite the prototype being a bit buggy, it worked remarkably well in user
    research sessions. It allowed participants to interact with the CLI
    naturally by typing commands, exploring different paths, and providing
    feedback on the various implementation options we were considering. The
    quality of user insights was substantially better than what we could have
    achieved through static mockups or theoretical discussions.
</FloatImage>

## Sharing user insights

<FanImages
    images={[
        {
            src: "/images/projects/maas-anvil/research-results-2.png",
            alt: "Research result document 2",
        },
        {
            src: "/images/projects/maas-anvil/research-results-1.png",
            alt: "Research preparation document 1",
        },
    ]}
    caption="Research preparation documents outlining study objectives and methodology"
/>

After having done the interviews I started to analyze them. Looking for research
trends across all interviews etc. Once I found some trends and insights I put
them into a UX heuristics matrix to make the different insights easier to
community to stakeholders. Once having the UX heuristics insights I compiled
more concrete suggestions in how to proceede with improving the tool and adding
new features. I presented all of this to my stakeholders in a meeting. Was
received well and we looked into how to fix. One of the biggest insights of the
research was that the documentation of the tool (including help messages in the
CLI) was not yet where it needed to be for users to confidently use the tool. As
I already had gotten a familiarity with the tool and an understand of what users
were unsure about I helped write the documentation and help messages in the
tool.

# Future of prototyping CLIs

After synthesizing and sharing the research findings with the team, I reflected
on the prototyping solution I'd created. The approach seemed valuable beyond our
immediate needs—potentially helpful for other designers conducting CLI user
research or anyone needing to quickly prototype command-line experiences.

<FloatImage src="/images/projects/maas-anvil/protostar.gif">
    This led me to develop it further as an open-source prototyping tool and
    library called Protostar. Protostar has already gained traction among
    designers at Canonical who need to test CLI interfaces. It also got some
    attention when Canonical's Design Director mentioned it during presentations
    on CLI design at FOSDEM, generating interest from the open-source community.
    What began as a practical solution to a specific research challenge has
    evolved into a specialized tool that fills a genuine gap in the UX design
    toolkit, particularly for those working with command-line interfaces.
</FloatImage>
